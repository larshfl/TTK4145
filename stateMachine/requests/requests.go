package requests

import (
	"../../types"
	"time"
)

// OrderList is the list that contains the laste order list generated by the distribitour
var OrderList []types.SingleOrder 
const maxTimeBeforeMotorError int = 5

// OpenDoorTimer starts a timer when newDoorTimer recieves true and sends true in dooeTimerFinished when done
func OpenDoorTimer(doorTimerFinished chan <- bool, newDoorTimer chan bool) {
	timer := time.NewTimer(types.DoorOpenTime * time.Second)
	for {
		select {
		case <- timer.C:
			doorTimerFinished <- true
			timer.Stop()
		case <- newDoorTimer:
			timer.Reset(types.DoorOpenTime * time.Second)
		}
	}
}

// ShouldStop decides if the elevator should stop
func ShouldStop(e types.Elevator) bool{
	if OrderList[0].Floor == e.Floor{
		return true
	}
	for orderIndex := 1; orderIndex < len(OrderList); orderIndex ++{
		if OrderList[orderIndex].Floor == e.Floor && 
		(buttonToDir(OrderList[orderIndex].Button) == e.Dir || 
		buttonToDir(OrderList[orderIndex].Button) == types.MotorDirectionStop) {
			return true
		}
	}
	return false
}


// ChooseDirection choose the new direction bades on the elavator state
func ChooseDirection(e types.Elevator) types.MotorDirection {
	if OrderList[0].Floor > e.Floor && e.Floor < types.NFloors {
		return types.MotorDirectionUp
	} else if OrderList[0].Floor < e.Floor && e.Floor > 0 {
		return types.MotorDirectionDown
	} else {
		return types.MotorDirectionStop
	} 
}

// CheckForMotorError checks if the motor don't work
func CheckForMotorError(motorError chan <- bool, resetMotorTimer chan bool, e* types.Elevator) {
	timer := time.NewTimer(time.Duration(maxTimeBeforeMotorError) * time.Second)

	for{
		select{
		case <- timer.C:
			if e.Behaviour == types.Moving {
				motorError <- true
			}
		case <- resetMotorTimer:
			timer.Reset(time.Duration(maxTimeBeforeMotorError) * time.Second)
		}
	}
}

// ClearOrders send the completed orders to distribitout to be deleted
func ClearOrders(completedOrdersCh chan types.SingleOrder,e types.Elevator) {
	for orderIndex := 0; orderIndex < len(OrderList); orderIndex++ {
		if OrderList[orderIndex].Floor == e.Floor{
			completedOrdersCh <- OrderList[orderIndex]
		}
	}
}


// Internal functions

func buttonToDir(b types.ButtonType) types.MotorDirection {
	switch b{
		case types.ButtonHallUp:
			return types.MotorDirectionUp
		case types.ButtonHallDown:
			return types.MotorDirectionDown
		default:
			return types.MotorDirectionStop
	}
}